#!/usr/bin/env python

import re
import sys
import tempfile

from typing import Any, Dict, Iterable, List, Optional, Set, Tuple

import pandas
import pybedtools

# from lorals import utils
import lorals.utils as utils

__all__: List[str] = [
    'Bpileup',
    'iter_var',
    'write_bed',
]

class Bpileup(object):

    """A BED-like pileup

    The BED-like pileup stores variant information that also allows
    easy translation to a BED-like file. This allows variants to be
    worked on via genomic arithmetic
    """

    @staticmethod
    def _valid_variant(var: str, mode: str='reference') -> None:
        if mode not in {'reference', 'alternate'}:
            mode: str = 'reference'
        valid_chars: Set[str] = set('ACGT')
        msg: str = 'The %s allele must contain only %s' % (mode, ','.join(valid_chars))
        if mode == 'alternate':
            valid_chars.update(',*')
        if not set(var.upper()).issubset(valid_chars):
            raise ValueError(msg)

    @staticmethod
    def default_id(chrom: str, position: int, ref: str, alt: str) -> str:
        """Create a default variant ID

        Args:
            chrom (str): Chromomosome or contig of the variant
            position (int): Position of the variant
            ref (str): Reference allele
            alt (str): Alternate alleles separated by commas

        Returns:
            str: The variant ID as '%(chrom)s_%(position)s_%(ref)s_%(alt)s'
        """
        Bpileup._valid_variant(var=ref, mode='reference')
        Bpileup._valid_variant(var=alt, mode='alternate')
        return "%(chr)s_%(pos)s_%(ref)s_%(alt)s" % {
            'chr': chrom,
            'pos': position,
            'ref': ref,
            'alt': alt
        }

    @classmethod
    def frominterval(cls, interval: pybedtools.cbedtools.Interval):
        """Create a Bpileup from an Interval"""
        if interval.file_type != 'bed':
            raise TypeError("Must be a BED interval")
        elif len(interval.fields) != 6:
            raise ValueError("wrong number of fields")
        return cls(
            chrom=interval.chrom,
            position=interval.end,
            ref=interval.fields[4],
            alt=interval.fields[5],
            name=interval.fields[3]
        )

    def __init__(self, chrom: str, position: int, ref: str, alt: str, name: Optional[str]=None,):
        """Initialize a Bpileup object

        Args:
            chrom (str): Chromosome/contig of the variant
            position (int): Position of the variant
            ref (str): Refererence allele of the variant
            alt (str): Alternate alleles in a comma-separated string
            name (str): Optional variant ID; if not provided, generated by Bpileup.default_id
        """
        #   Validate data
        ref: str = str(ref)
        alt: str = str(alt)
        self._valid_variant(var=ref, mode='reference')
        self._valid_variant(var=alt, mode='alternate')
        #   Fill in the data
        self._chrom: str = str(chrom)
        self._pos: int = int(position)
        self._ref: str = ref
        self._alt: Tuple[str, ...] = tuple(alt.split(','))
        if name:
            self._id: str = str(name)
        else:
            self._id: str = self._default_id()

    def __str__(self) -> str:
        out: Tuple = (
            self.chrom,
            self.dummy,
            self.position,
            self.name
        )
        return '\t'.join(map(str, out))

    def __repr__(self) -> str:
        return self.name

    def __hash__(self) -> int:
        return hash(self._default_id())

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Bpileup):
            return hash(self) == hash(other)
        elif isinstance(other, str):
            return self.name == other or self._default_id() == other
        return NotImplemented

    def _default_id(self) -> str:
        return Bpileup.default_id(
            chrom=self.chrom,
            position=self.position,
            ref=self.ref,
            alt=self.alts
        )

    def bed(self, default: bool=False):
        """Format this Bpileup to a bed4 format

        Args:
            default (bool): If True, uses the default ID as generated by Bpileup.default_id

        Returns:
            str: A string with the information in a BED4 format
        """
        return "%(chr)s\t%(start)s\t%(end)s\t%(name)s" % {
            'chr': self.chrom,
            'start': self.dummy,
            'end': self.position,
            'name': self._default_id() if default else self.name
        }

    chrom = property(fget=lambda self: self._chrom, doc="Chromsome of this variant")
    position = property(fget=lambda self: self._pos, doc="Position of this variant")
    dummy = property(fget=lambda self: self.position - 1, doc="Dummy starting position")
    ref = property(fget=lambda self: self._ref, doc="Reference allele")
    alt = property(fget=lambda self: self._alt, doc="Alternate variant(s)")
    alts = property(fget=lambda self: ','.join(self.alt), doc="Alternate variant(s) as a string")
    name = property(fget=lambda self: self._id, doc="Variant name/ID")
    default = property(fget=lambda self: self._default_id(), doc="Standardized default ID")


class GenoVar(Bpileup):

    @staticmethod
    def _valid_genotype(genotype: str) -> None:
        if genotype:
            genos: List[str] = genotype.split(',')
            for gt in genos: # type: str
                if not re.match(r'[01][/|][01]', gt):
                    raise ValueError("invalid genotypes")
        return None

    @classmethod
    def fromvcf(cls, vcf: str):
        vcf: List[str] = vcf.strip().split('\t')
        gt_index: int = vcf[8].split(':').index('GT')
        gt: Tuple[str, ...] = tuple(x.split(':')[gt_index] for x in vcf[9:])
        return cls(
            chrom=vcf[0],
            position=vcf[1],
            ref=vcf[3],
            alt=vcf[4],
            geno=','.join(gt),
            name=vcf[2]
        )

    def __init__(
        self,
        chrom: str,
        position: int,
        ref: str,
        alt: str,
        geno: Optional[str]=None,
        name: Optional[str]=None
    ) -> None:
        super(GenoVar, self).__init__(chrom=chrom, position=position, ref=ref, alt=alt, name=name)
        geno: str = str(geno) if geno is not None else ""
        self._valid_genotype(genotype=geno)
        self._geno: Tuple[str, ...] = tuple(geno.split(','))

    @property
    def geno(self) -> Tuple[str, ...]:
        return self._geno

    @geno.setter
    def geno(self, value: str) -> None:
        self._valid_genotype(genotype=value)
        self._geno: Tuple[str, ...] = tuple(value.split(','))

    genos = property(fget=lambda self: ','.join(self.geno), doc='')


def iter_var(df: pandas.core.frame.DataFrame) -> Iterable[Bpileup]:
    """Yield Bpileups from a data frame"""
    if tuple(df.columns) != ('contig', 'dummy', 'position', 'variantID', 'refAllele', 'altAllele'):
        raise ValueError("Invalid data frame")
    for x in df.itertuples():
        yield Bpileup(
            chrom=x.contig,
            position=x.position,
            ref=x.refAllele,
            alt=x.altAllele,
            name=x.variantID
        )


def write_bed(bpileups: Iterable[Bpileup], default: bool=False, ofile: Optional[str]=None) -> str:
    if ofile:
        ofh = utils.find_open(filename=ofile)(ofile, 'w+b')
    else:
        ofh = tempfile.NamedTemporaryFile(mode='w', delete=False)
    for bp in bpileups: # type: Bpileup
        ofh.write(bp.bed(default=default))
        ofh.write('\n')
        ofh.flush()
    ofh.close()
    return ofh.name
